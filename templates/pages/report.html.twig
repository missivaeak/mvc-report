{% extends "base.html.twig" %}

{% block title %}{{title}}{% endblock %}

{% block body %}
    <nav class="nav small">
        <a href="#kmom01">kmom01</a>
        <a href="#kmom02">kmom02</a>
        <a href="#kmom03">kmom03</a>
        <a href="#kmom04">kmom04</a>
        <a href="#kmom05">kmom05</a>
        <a href="#kmom06">kmom06</a>
        <a href="#kmom10">kmom10</a>
    </nav>
    <p>Redovisningstexter för samtliga kursmoment.</p>
    <section>
        <h2 id="kmom01">kmom01</h2>
        <p>Min tidigare erfarenheter med objektorientering är enbart oopython-kursen som vi precis gick på programmet.</p>
        <p>Det känns som att det är väldigt likt pythons klasser och objekt hittills. Relationen mellan klass och objekt samt hur konstruktorer och instanser fungerar känn som kärnan i idéen. Jag gillade konstruktionen med en autoloader.</p>
        <p>Det känns lite som att fuska att använda något så omfattande som symfony, som har så mycket kod som jag inte vet hur det fungerar. Kodstrukturen känns lite svårgreppbar just nu, men det kanske löser sig med lite mer arbete kring det. Idéen med routes och templates är bekant vid det här laget.</p>
        <p>Det var en väldigt stort dokument så jag har inte läst det från pärm till pärm, men vid snabb anblick så gillar jag att det finns resurser för stilguider, kodstruktur, phpdoc, praktiker. Om det är så bra som det utlovar så är det en väldigt bra resurs!</p>
        <p>Min TIL var vad -> betyder i php, har jag funderat lite på innan.</p>
    </section>
    <section>
        <h2 id="kmom02">kmom02</h2>

        <p>Arv och komposition beskriver hur objekt är sammansatta. Arv beskriver att något är en delpart av något mer generellt. T.ex. så är ett bil ett fordon, en bil-klass kan då tänkas ärva delar från en fordons-klass. Komposition är när ett objekt har ett annat objekt som beståndsdel.</p>

        <p>Traits är en funktionalitet som kan återkomma eller återanvändas i flera klasser. De är konstruerade enligt väldigt lika regler som en klass, förutom att de behöver inkluderas i en annan klass för att kunna åstadkomma något. Meningen är att de ska ha en funktionalitet som är nyttig för flera klasser.<p>

        <p>Interface är en abstrakt beskrivning av en klass metoder. Om en klass implementerar ett interface så måste den klassen uppfylla interfacets beskrivning. Sedan kan andra delar av koden referera till det interfacet istället för en specifik klass när programmeraren t.ex. vill specificera en giltig klass av parameter. Då kan programmerar lita på att den minimifunktionalitet som beskrivs i interfacet uppfylls och kan då tillåta fler sorters parametrar användas i sin kod. Det blir ett sätt att säga jag vill enbart att "denna sortens klasser" ska användas här, istället för att hårdkoda en särskilt klass.</p>

        <p>Jag är på det hela nöjd. Jag försökte använda arv, komposition och interface på ett rimligt vis. Jag gjorde så att en kortlek (Deck) och en hand (Hand) ärver från en abstrakt klass (CardCollectionAbstract) då jag behövde få med ett arv och jag ville testa en abstrakt. Jag använde ett interface för korten (Card och CardInterface), det var ju lite överflödigt då jag bara har ett sorts kort, men jag ville testa och det är ju tänkbart att det finns andra sorters kort. För att förbättra koden så skulle jag kanske kunna tänka ut ett sätt att använda traits, eller kanske utöka min Hand-klass med lite mer specifik funktionalitet.</p>

        <p>Jag tror inte att det är ett stöd att förbereda arbetet med diagram i just denna uppgift. Det är såpass litet system, det är egentligen bara två saker som ska samverka (kort och kortlek). Det är lätt att få en överblick över systemet i huvudet. Med ett större och mer komplicerat system så hade det varit mer hjälpsamt.</p>

        <p>Jag kunde inte stoppa in en klass som en parameter i en konstruktor, det trodde jag att jag kunde göra. Jag ville göra $deck = new Deck(Card), för att berätta vilken sorts kort som kortleken skulle fyllas med. Efter lite tråcklande så bestämde jag mig för att göra på ett annat vis.</p>
    </section>
    <section>
        <h2 id="kmom03">kmom03</h2>
        <p>Det var absolut väldigt bra med flödesschema och pseudokod i denna uppgift. Flödesschemat som visade upp alla besultssteg var väldigt bra för att jag skulle verkligen förstå alla stegen. Pseudokoden som jag valde att fokusera var något som jag redan börjat jobba på i mitt huvud så att fortsätta med det i pseudokod-form var definitivt bra. Jag valde att göra ett rätt så komplicerat spel, jag tror att det hade väldigt mycket svårare utan detta förarbete.</p>

        <p>Jag gjorde spelet Gin Rummy och jag tyckte det blev helt okej till slut. Det var så pass mycket arbete att det finns vissa tydliga förbättringsområden. Motståndaren spelar inte särskilt intelligent, den slänger bara det högsta omatchade kortet. Dessutom så ser det lite märkligt ut om man har en serie på 6 kort så kommer det egentligen vara 2 serier med 3 kort, det skulle jag kunna åtgärda.</p>

        <p>Vad gäller klasserna så kändes det som strukturen var rätt så bra. Jag använde ett interface som bara implementerades i en klass (StandardPlayingCard-CardInterface), och ett trait som bara användes av en klass (StandardPlayingCardsTrait-StandardPlayingCardsDeck). Detta blev lite onödigt men känns ändå rimligt i sammanhang av hur specifika/generella de två paren är.</p>

        <p>Jag har börjat gilla Symfony väldigt mycket hittills. Man får mycket saker lätt tillgängligt, t.ex. bättre session och enkla flashmeddelanden.</p>

        <p>Min största lärdom i denna uppgift har varit hur bra Liskov Substitution Principle är i praktiken. Jag använde samma taxonomi och vokabulär i metoderna i klasserna och det gjorde det väldigt lätt att jobba med alla objektet som fanns i spelet. Att plocka fram ett specifikt kort ur handen är bara <code>$game->getPlayer->getHand->drawCardByPattern("hearts", 3);</code> och samma funkar för <code>$game->getDiscard->drawCardByPattern("diamonds", 10);</code>.</p>
    </section>
    <section>
        <h2 id="kmom04">kmom04</h2>

        <p>Det kändes bra att använda phpunit, jag saknade ett testverktyg när jag utvecklade. Tidigare så har jag bara jobbat med pythons, phpdoc kändes bra att göra mocks och stubs i. Det var också bra att få en lista över vilka rader i koden som har körts.</p>

        <p>Till slut lyckades jag nå 90%. Jag hade väldigt svårt att göra testfall för ett par metoder i GinRummyScoring, så de gjorde jag utan att mocka. Jag saknade eller lyckades inte hitta hur man skriver in egna funktioner i mockobjekten. Övriga delar gick bra att skriva test för efter jag hade läst på hur stubs och mocks funkade.</p>

        <p>Jag skriv om några metoder som var kedjade där de efterkommande metoderna var privata metoder. Jag gjorde om dem till publika metoder och skriv om strukturen så att alla metodernas kallas på explicit i min kontroller. Även några småfix, som var så små att jag inte ens minns dem längre.</p>

        <p>Spontant så känns det som att för att göra testbar kod så ser man till att ens funktioner är rättfram och inte gör för mycket olika saker, och det ger också snygg och ren kod.</p>

        <p>Jag fick se skälet till att vi ska använda dependency injection. Jag gjorde det när jag skrev koden för att jag fick höra att det var bra, nu fick jag erfara varför! Det gjorde mockningen lätt.</p>
    </section>
    <section>
        <h2 id="kmom05">kmom05</h2>

        <p>Det känns som det gick bra. När jag jobbade genom övningen så trillade poletten ner vad ORM betyder. Utöver det så var det bara att jobba igenom för att se hur allt funkar.</p>

        <p>Jag började med att göra routes för varje del av CRUD och när det var klart så plockade jag ihop allt i en och samma sida på det viset det ser ut nu. Det känns som att det var rätt så basic, men det blev helt okej.</p>

        <p>Jag tyckte det kändes lite krångligt att använda ORM när jag vet hur man skriver SQL-uttryck redan. Men jag kan se att det finns fördelar att koppla ihop databasen lite tätare med resten av koden. Överlag så känner jag tog att det döljer lite väl mycket för programmeraren.</p>

        <p>Min största lärdom detta kursmoment var insikten hur kraftfullt det kan vara med moduler som sköter särskilda delar. Det är ju inget konstigt i sig med att ett objekt gör SQL-förfrågan, men det visar hur lätt det kan vara att ta in nya saker som nån annan har förberett som en modul.</p>
    </section>
    <section>
        <h2 id="kmom06">kmom06</h2>

        <p>Phpmetrics verkade vara ett första steg för att samla många olika mätvärden. Den listar många olika värden och det verkar som att det mesta man vill hitta finns där nånstans, men jag tyckte det var svårt att hitta det man letade efter. Jag gillade issuesen i phpmetrics, de gav råd på mer strategisk nivå än scrutinizers issues. </p>

        <p>Scrutinizers integrering gick okej. Jag behövde lägga till environment php version för att det skulle funka, men utöver det inga större problem. Jag gillade att verktygen verkligen går fullt i att försöka förenkla och presentera problemområden på ett lättsmält vis. Det blir lätt att hitta vad som bör vara de största problemen för vidare analys. I första bygget hade jag 9.67 i scrutinizers betyg och 99% kodtäckning.</p>

        <p>Jag föreställer mig att bra kodkvalitet bara har ett löst samband med bra betyg på badges, men det är säkert så att alla projekt med dåliga badges har dålig kodkvalitet. Så bra eller åtminstonde tillräckliga badges/betyg kanske är att ses som ett minimikrav, och dåliga eller inga badges är en varningssignal.</p>

        <p>Detta kursmoments TIL var hur mycket bättre kod jag själv kan skriva efter bara en vecka längre med projektet. I refaktoreringen så slog jag ihop lite metoder som hade liknande funktion och den bättre metoden var så otroligt mycket bättre skriven utan att jag egentligen lärt mig nåt nytt, enbart för att jag hade bättre implementering.</p>
    </section>
    <section>
        <h2 id="kmom10">kmom10</h2>

        <h3>Krav 1-3</h3>

        <p>Jag valde att göra ett eget fokus på projektet, men idéen om ett äventyrsspel intresserade mig så jag blev inspirerad av det. Istället för ett spel med en bestämd struktur så ville jag göra ett som genereras automatiskt och slumpmässigt varje gång man spelar. På så vis så kunde jag få in databasobjekt som grund för spelets genererade innehåll.</p>

        <p>Som stil så valde jag att utgå från idéen om en väg och valde jordnära färger och komplementfärg till det, samt typsnitt som var slavrigt skrivna och för tankarna till något man skriver i grus.</p>

        <p>I <a href="https://github.com/missivaeak/mvc-report">repot</a> finns README.md med instruktioner för hur man bygger sidan. Dessutom finns genererad <a href="../docs/api/">dokumentation</a>, statisk kodanalys via <a href="../docs/metrics">phpmetrics</a> och kodtäckning via <a href="../docs/coverage/Roadlike/index.html">phpunit</a>.</p>

        <figure>
            <a href="https://scrutinizer-ci.com/g/missivaeak/mvc-report/?branch=main"><img src="https://scrutinizer-ci.com/g/missivaeak/mvc-report/badges/quality-score.png?b=main" alt="Scrutinizer Code Quality"></a> <a href="https://scrutinizer-ci.com/g/missivaeak/mvc-report/?branch=main"><img src="https://scrutinizer-ci.com/g/missivaeak/mvc-report/badges/coverage.png?b=main" alt="Code Coverage"></a> <a href="https://scrutinizer-ci.com/g/missivaeak/mvc-report/build-status/main"><img src="https://scrutinizer-ci.com/g/missivaeak/mvc-report/badges/build.png?b=main" alt="Build Status"></a>
            <figcaption><i>Sidans scrutinizer badges.</i></figcaption>
        </figure>

        <p>Jag tyckte projektet gick bra. Jag hade en bra idé om strukturen och implementationen jag tänkte använda. Jag började med att göra klasserna för spelet, Obstacle, Road, Crossroads, Challenger och Manager, och samtidigt gjorde jag enhetstesterna. Jag tycker att det är ett väldigt bra sätt att jobba, enhetstester och enheter samtidigt. Jag hade nästan inga buggar i min kod när jag började sammanställa hemsidan.</p>

        <h3>Krav 4</h3>

        <p><a href="{{path('proj_api')}}">API</a> endpointsen gjorde jag samtidigt som databasen och använde dem som utvecklingsverktyg när jag gjorde allt som kommunicerade med databasen, samt att populera databasen. På det viset kunde jag jobba med databasen och ORM först och sen göra hemsidan separat, även detta hjälpte mycket med att minska antalet buggar jag stötte på senare.</p>

        <p>Jag har länkat till GET routes, POST och DELETE routes når man via postman eller motsvarande tjänst.</p>

        <h3>Krav 5</h3>

        <p>Sidan använder SQLite som databas. Doctrines sätt att lägga till tabeller fungerar helt okej. Jag fick ett fel som kändes som en bugg när jag skulle lägga till ett nytt fält i en tabell, så jag var tvungen att gå in i migration-filen och ändra så att SQL-uttrycket blev rätt och migrationen funkar. Dessutom hade jag mycket arbete att göra med att kontrollera för nullbara returns från Entities, något som kändes störande då fälten var <code>NOT NULL</code> i schemat. Jag övervägde att redigera i Entities, men det kändes som att det skulle vara mer arbete än att kontrollera för null, även om det också tog mycket tid.</p>

        <p>Förutom dessa bekymmer gick det helt okej. Jag gjorde en ORM-klass som fick sköta allt med Entities och Repositories att göra. Det är väl det som Entities och Repositories ska göra, men detta kändes enklare för mig. Jag fick till ett bra flöde med APIer och backup genom en dumpad fil och ladda in med symfony's console.</p>

        <h3>Krav 6</h3>

        <p>Här vill jag lyfta fram några saker som jag valde att lägga extra fokus utöver grundkraven.</p>

        <p>Först och främst vill jag lyfta fram sidans design, färgerna och typsnittet fungerar bra tillsammans och med syftet. Dessutom använde jag animationer och transitions till vissa saker för att få sidan att kännas mer interaktiv.</p>

        <p>Det andra gäller projektets testbarhet. Jag använde dependency injection och pure functions såpass mycket att testningen var mycket enkel att genomföra och det märks i scrutinizers utvärdering av repot.</p>

        <p>Som sista extragrej lyfter jag fram metoden och tillhörande privata metoder som beräknar hur ett obstacle attempt beräknas. Strukturen på metoderna blev väldigt tydlig och bra, samt beräkningarna använder sig av naturlig logaritm för att åstadkomma en utvecklingskurva som gör att förändringar minskar mer och mer.</p>

        <h3>Allmänt</h3>

        <p>Det var ett kul och rimligt projekt, tycker jag. Det blev sin beskärda del av problem förstås, men ändå rätt så få problem. Det känns trevligt att skriva kod i php, och symfony fungerar bra. Det var inget särskilt som tog extra lång tid utan att flöt på i jämnt tempo.</p>

        <p>Det enda jag hade mycket problem med var problem som phpstans typ-förståelse flaggade för. Det berodde på nullbara värden. Jag fick lösa det med att kontrollera för null eller kontrollera för rätt typ, inga konstigheter, men det blir en del arbete när det gäller kedjor av data i flera metoder och genom databasen och requests, osv.</p>

        <p>Det enda jag inte var helt nöjd med var att vi skulle jobba vidare med report-repot. Jag skulle vilja börja om från början med ett nytt repo.</p>

        <h3>Avslutningsvis</h3>

        <p>Jag ger kursen och handledning bra betyg. Det har varit väldigt lärorikt att börja skriva källkod i php, det har definitivt givit mig en uppskattning för att vissa programmeringsspråk är bättre/lättare att jobba med. Jag jämför med att skriva javascript-kod, som ibland känns krångligt.</p>

        <p>Jag uppskattade också att vi hade ett lite längre kursmoment med en större uppgift i mitten, det gav möjlighet till en djupdykning innan projektet som jag tror gav rätt så mycket.</p>

        <p>Jag ger kursen 9/10.</p>
    </section>
{% endblock %}